# Operator Overloading: Making Custom Objects Behave Like Built-ins

## Community Attitude: "Powerful When Used Right, Confusing When Abused"

**Consensus**: Operator overloading is powerful but can hurt readability if misused. Community favors explicit methods for complex operations.

**Golden rule**: Make operators behave like users expect. `+` should feel like addition, not file concatenation.

## What Operator Overloading Actually Does

Allows custom objects to work with Python's built-in operators (`+`, `-`, `*`, `==`, `<`, `[]`, etc.) by implementing special methods (dunder methods).

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    def __repr__(self):
        return f"Vector({self.x}, {self.y})"

# Now vectors behave like built-in types
v1 = Vector(1, 2)
v2 = Vector(3, 4)
v3 = v1 + v2  # Vector(4, 6) - feels natural!
```

## When Operator Overloading Is Worth Using

### 1. Mathematical Objects (Best Use Case)
```python
from dataclasses import dataclass
from typing import Union

@dataclass
class Complex:
    real: float
    imag: float
    
    def __add__(self, other: Union['Complex', float]) -> 'Complex':
        if isinstance(other, Complex):
            return Complex(self.real + other.real, self.imag + other.imag)
        return Complex(self.real + other, self.imag)
    
    def __mul__(self, other: Union['Complex', float]) -> 'Complex':
        if isinstance(other, Complex):
            # (a + bi)(c + di) = (ac - bd) + (ad + bc)i
            real = self.real * other.real - self.imag * other.imag
            imag = self.real * other.imag + self.imag * other.real
            return Complex(real, imag)
        return Complex(self.real * other, self.imag * other)
    
    def __abs__(self) -> float:
        return (self.real**2 + self.imag**2)**0.5
    
    def __eq__(self, other) -> bool:
        if isinstance(other, Complex):
            return self.real == other.real and self.imag == other.imag
        return False

# Natural mathematical operations
c1 = Complex(1, 2)
c2 = Complex(3, 4)
result = c1 + c2 * 2  # Feels like math!
magnitude = abs(c1)   # Pythonic
```

### 2. Container-Like Objects
```python
class Matrix:
    def __init__(self, data):
        self.data = data
        self.rows = len(data)
        self.cols = len(data[0]) if data else 0
    
    def __getitem__(self, key):
        """Enable matrix[row, col] syntax"""
        if isinstance(key, tuple):
            row, col = key
            return self.data[row][col]
        return self.data[key]
    
    def __setitem__(self, key, value):
        """Enable matrix[row, col] = value"""
        if isinstance(key, tuple):
            row, col = key
            self.data[row][col] = value
        else:
            self.data[key] = value
    
    def __len__(self):
        return self.rows
    
    def __contains__(self, value):
        """Enable 'value in matrix'"""
        for row in self.data:
            if value in row:
                return True
        return False
    
    def __iter__(self):
        """Enable 'for row in matrix'"""
        return iter(self.data)

# Behaves like built-in containers
matrix = Matrix([[1, 2], [3, 4]])
print(matrix[0, 1])  # 2 - natural indexing
matrix[1, 0] = 5     # Assignment works
print(len(matrix))   # 2 - number of rows
print(2 in matrix)   # True - membership testing
```

### 3. Comparison-Rich Objects
```python
from dataclasses import dataclass
from functools import total_ordering

@total_ordering  # Generates all comparison operators from __eq__ and __lt__
@dataclass
class Version:
    major: int
    minor: int
    patch: int
    
    def __eq__(self, other):
        if isinstance(other, Version):
            return (self.major, self.minor, self.patch) == (other.major, other.minor, other.patch)
        return NotImplemented
    
    def __lt__(self, other):
        if isinstance(other, Version):
            return (self.major, self.minor, self.patch) < (other.major, other.minor, other.patch)
        return NotImplemented
    
    def __str__(self):
        return f"{self.major}.{self.minor}.{self.patch}"

# Natural version comparison
v1 = Version(1, 2, 3)
v2 = Version(1, 2, 4)
print(v1 < v2)   # True
print(v1 <= v2)  # True (generated by @total_ordering)
print(v1 != v2)  # True (generated by @total_ordering)

# Works with sorted(), max(), min()
versions = [Version(2, 1, 0), Version(1, 5, 3), Version(2, 0, 1)]
latest = max(versions)  # Version(2, 1, 0)
```

## When NOT to Use Operator Overloading

### ❌ Non-Obvious Operations
```python
# BAD: Confusing operator usage
class Logger:
    def __init__(self):
        self.messages = []
    
    def __add__(self, message):  # What does Logger + message mean?
        self.messages.append(message)
        return self
    
    def __mul__(self, count):    # What does Logger * 3 mean?
        return [self] * count

# GOOD: Explicit methods
class Logger:
    def __init__(self):
        self.messages = []
    
    def log(self, message):      # Clear intent
        self.messages.append(message)
    
    def duplicate(self, count):  # Clear intent
        return [Logger() for _ in range(count)]
```

### ❌ Side Effects in Operators
```python
# BAD: Operators with side effects
class Database:
    def __add__(self, record):
        self.insert(record)  # Side effect! Violates expectations
        return self

# GOOD: Operators return new objects, methods have side effects
class Database:
    def insert(self, record):     # Clear side effect
        # Insert record
        pass
    
    def merge(self, other_db):    # Returns new object
        # Return combined database
        pass
```

### ❌ Overloading for Performance
```python
# BAD: Premature optimization through operators
class FastString:
    def __init__(self, data):
        self.data = data
    
    def __lshift__(self, other):  # Using << for string append? Confusing!
        return FastString(self.data + other)

# GOOD: Use appropriate methods
class FastString:
    def __init__(self, data):
        self.data = data
    
    def append(self, other):      # Clear intent
        return FastString(self.data + other)
```

## Essential Operators to Implement

### 1. String Representation
```python
class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age
    
    def __str__(self):
        """Human-readable string (for end users)"""
        return f"{self.name}, {self.age} years old"
    
    def __repr__(self):
        """Developer-friendly string (for debugging)"""
        return f"Person(name='{self.name}', age={self.age})"

person = Person("Alice", 30)
print(str(person))   # Alice, 30 years old
print(repr(person))  # Person(name='Alice', age=30)
print(person)        # Uses __str__ by default
```

### 2. Equality and Hashing
```python
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __eq__(self, other):
        if isinstance(other, Point):
            return self.x == other.x and self.y == other.y
        return NotImplemented
    
    def __hash__(self):
        """Enable use in sets and as dict keys"""
        return hash((self.x, self.y))
    
    def __repr__(self):
        return f"Point({self.x}, {self.y})"

# Now Points work like built-in immutable types
p1 = Point(1, 2)
p2 = Point(1, 2)
print(p1 == p2)      # True
print(p1 is p2)      # False

# Can use in sets and as dict keys
points = {p1, p2}    # Only one Point(1, 2) in set
mapping = {p1: "origin"}  # Point as dictionary key
```

### 3. Container Protocol
```python
class PlayList:
    def __init__(self):
        self.songs = []
    
    def __len__(self):
        return len(self.songs)
    
    def __getitem__(self, index):
        return self.songs[index]
    
    def __setitem__(self, index, song):
        self.songs[index] = song
    
    def __delitem__(self, index):
        del self.songs[index]
    
    def __contains__(self, song):
        return song in self.songs
    
    def __iter__(self):
        return iter(self.songs)
    
    def append(self, song):
        self.songs.append(song)

# Behaves like a list
playlist = PlayList()
playlist.append("Song 1")
playlist.append("Song 2")

print(len(playlist))           # 2
print(playlist[0])             # Song 1
print("Song 1" in playlist)    # True
for song in playlist:          # Iteration works
    print(song)
```

## Advanced Patterns

### 1. Context-Aware Operators
```python
class Unit:
    def __init__(self, value, unit_type):
        self.value = value
        self.unit_type = unit_type
    
    def __add__(self, other):
        if isinstance(other, Unit):
            if self.unit_type == other.unit_type:
                return Unit(self.value + other.value, self.unit_type)
            else:
                # Attempt unit conversion
                converted = self._convert_units(other, self.unit_type)
                return Unit(self.value + converted.value, self.unit_type)
        return NotImplemented
    
    def _convert_units(self, other, target_type):
        # Simplified unit conversion
        conversions = {
            ('meters', 'feet'): 3.28084,
            ('feet', 'meters'): 0.3048,
        }
        factor = conversions.get((other.unit_type, target_type), 1)
        return Unit(other.value * factor, target_type)
    
    def __repr__(self):
        return f"Unit({self.value}, '{self.unit_type}')"

# Smart unit arithmetic
distance1 = Unit(10, 'meters')
distance2 = Unit(5, 'feet')
total = distance1 + distance2  # Automatic conversion
```

### 2. Chaining Operations
```python
class QueryBuilder:
    def __init__(self, table=None):
        self.table = table
        self.conditions = []
        self.order_by_clause = None
    
    def __call__(self, table):
        """Enable QueryBuilder()(table) syntax"""
        return QueryBuilder(table)
    
    def __getitem__(self, condition):
        """Enable query[condition] syntax for filtering"""
        new_query = QueryBuilder(self.table)
        new_query.conditions = self.conditions + [condition]
        new_query.order_by_clause = self.order_by_clause
        return new_query
    
    def __rshift__(self, order_field):
        """Enable query >> 'field' syntax for ordering"""
        new_query = QueryBuilder(self.table)
        new_query.conditions = self.conditions[:]
        new_query.order_by_clause = order_field
        return new_query
    
    def build(self):
        query = f"SELECT * FROM {self.table}"
        if self.conditions:
            query += " WHERE " + " AND ".join(self.conditions)
        if self.order_by_clause:
            query += f" ORDER BY {self.order_by_clause}"
        return query

# Fluent query building
query = QueryBuilder()
sql = (query('users')['age > 18']['status = "active"'] >> 'name').build()
# "SELECT * FROM users WHERE age > 18 AND status = "active" ORDER BY name"
```

### 3. Mathematical Function Objects
```python
class Polynomial:
    def __init__(self, coefficients):
        # coefficients[0] is constant term, coefficients[1] is x term, etc.
        self.coefficients = coefficients
    
    def __call__(self, x):
        """Enable poly(x) syntax - evaluate polynomial at x"""
        result = 0
        for i, coeff in enumerate(self.coefficients):
            result += coeff * (x ** i)
        return result
    
    def __add__(self, other):
        if isinstance(other, Polynomial):
            # Add polynomials by adding coefficients
            max_len = max(len(self.coefficients), len(other.coefficients))
            result_coeffs = []
            for i in range(max_len):
                a = self.coefficients[i] if i < len(self.coefficients) else 0
                b = other.coefficients[i] if i < len(other.coefficients) else 0
                result_coeffs.append(a + b)
            return Polynomial(result_coeffs)
        return NotImplemented
    
    def __mul__(self, scalar):
        """Multiply polynomial by scalar"""
        if isinstance(scalar, (int, float)):
            return Polynomial([coeff * scalar for coeff in self.coefficients])
        return NotImplemented
    
    def __repr__(self):
        terms = []
        for i, coeff in enumerate(self.coefficients):
            if coeff != 0:
                if i == 0:
                    terms.append(str(coeff))
                elif i == 1:
                    terms.append(f"{coeff}x")
                else:
                    terms.append(f"{coeff}x^{i}")
        return " + ".join(terms) if terms else "0"

# Natural polynomial operations
p1 = Polynomial([1, 2, 3])  # 1 + 2x + 3x²
p2 = Polynomial([0, 1])     # x
p3 = p1 + p2                # 1 + 3x + 3x²

print(p1(2))    # Evaluate at x=2: 1 + 2(2) + 3(4) = 17
print(p3)       # 1 + 3x + 3x²
```

## Performance Considerations

### Operator Call Overhead
```python
import timeit

class FastMath:
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        return FastMath(self.value + other.value)
    
    def add_method(self, other):
        return FastMath(self.value + other.value)

# Performance comparison
a = FastMath(1)
b = FastMath(2)

# Operator overloading
operator_time = timeit.timeit(
    lambda: a + b,
    number=1_000_000
)

# Method call
method_time = timeit.timeit(
    lambda: a.add_method(b),
    number=1_000_000
)

print(f"Operator: {operator_time:.4f}s")
print(f"Method:   {method_time:.4f}s")
# Operators are slightly slower due to method lookup overhead
```

### Memory Efficiency with __slots__
```python
class EfficientVector:
    __slots__ = ['x', 'y']
    
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return EfficientVector(self.x + other.x, self.y + other.y)
    
    def __mul__(self, scalar):
        return EfficientVector(self.x * scalar, self.y * scalar)

# Combine operator overloading with memory optimization
```

## Common Pitfalls and Solutions

### 1. Forgetting Return NotImplemented
```python
# BAD: Raises TypeError instead of allowing reverse operation
class BadNumber:
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        if isinstance(other, BadNumber):
            return BadNumber(self.value + other.value)
        raise TypeError("Unsupported type")  # WRONG!

# GOOD: Return NotImplemented to allow reverse operation
class GoodNumber:
    def __init__(self, value):
        self.value = value
    
    def __add__(self, other):
        if isinstance(other, GoodNumber):
            return GoodNumber(self.value + other.value)
        elif isinstance(other, (int, float)):
            return GoodNumber(self.value + other)
        return NotImplemented  # Let Python try other.__radd__
    
    def __radd__(self, other):
        return self.__add__(other)

# Now both directions work
num = GoodNumber(5)
result1 = num + 3      # GoodNumber.__add__
result2 = 3 + num      # GoodNumber.__radd__
```

### 2. Inconsistent Operator Behavior
```python
# BAD: Inconsistent behavior
class InconsistentClass:
    def __init__(self, value):
        self.value = value
    
    def __eq__(self, other):
        return self.value == other.value
    
    # Missing __hash__ - breaks dict/set usage!

# GOOD: Consistent equality and hashing
class ConsistentClass:
    def __init__(self, value):
        self.value = value
    
    def __eq__(self, other):
        if isinstance(other, ConsistentClass):
            return self.value == other.value
        return NotImplemented
    
    def __hash__(self):
        return hash(self.value)
```

### 3. Mutating in Operators
```python
# BAD: Mutating self in operators
class MutableVector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        self.x += other.x  # WRONG! Mutates self
        self.y += other.y
        return self

# GOOD: Return new objects
class ImmutableVector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):
        return ImmutableVector(self.x + other.x, self.y + other.y)
    
    def __iadd__(self, other):  # Separate in-place operator
        self.x += other.x
        self.y += other.y
        return self
```

## Testing Operator Overloading

```python
import pytest

class TestVector:
    def test_addition(self):
        v1 = Vector(1, 2)
        v2 = Vector(3, 4)
        result = v1 + v2
        
        assert result.x == 4
        assert result.y == 6
        assert v1.x == 1  # Original unchanged
        assert v1.y == 2
    
    def test_equality(self):
        v1 = Vector(1, 2)
        v2 = Vector(1, 2)
        v3 = Vector(2, 1)
        
        assert v1 == v2
        assert v1 != v3
        assert not (v1 == "not a vector")
    
    def test_container_behavior(self):
        playlist = PlayList()
        playlist.append("Song 1")
        
        assert len(playlist) == 1
        assert "Song 1" in playlist
        assert playlist[0] == "Song 1"
    
    def test_comparison_ordering(self):
        v1 = Version(1, 0, 0)
        v2 = Version(1, 1, 0)
        v3 = Version(2, 0, 0)
        
        assert v1 < v2 < v3
        assert v3 > v2 > v1
        assert sorted([v3, v1, v2]) == [v1, v2, v3]
```

## Decision Matrix

| Use Case | Implement Operators | Use Methods | Reason |
|----------|-------------------|-------------|---------|
| Mathematical objects | ✅ | ❌ | Natural syntax |
| Container-like objects | ✅ | ✅ | Both useful |
| Complex business logic | ❌ | ✅ | Clarity over cleverness |
| File operations | ❌ | ✅ | Side effects unclear |
| Comparison objects | ✅ | ❌ | Sorting, built-in compatibility |
| String-like objects | ✅ | ✅ | Both useful |
| Network operations | ❌ | ✅ | Non-obvious semantics |

## Bottom Line

**Use operator overloading when:**
- Operations have obvious, mathematical meaning
- Objects behave like built-in types (numbers, containers)
- You want natural syntax for domain objects
- Operators follow expected conventions

**Avoid operator overloading when:**
- Operations have side effects
- Meaning is not obvious to users
- You're tempted to be "clever"
- Methods would be clearer

**Community wisdom**: Operator overloading is powerful but should feel natural. If users have to think about what an operator does, use a method instead. The best operator overloading is invisible—it just makes objects work like users expect them to.